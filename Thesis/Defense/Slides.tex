\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}

\usetheme{Darmstadt}
\useoutertheme{miniframes}
\makeatletter
  \beamer@compressfalse
\makeatother

\title{Formalnie zweryfikowane algorytmy w Coqu: koncepcje i techniki}
\author{Wojciech Kołowski}
\date{27 września 2021}

\begin{document}

\frame{\titlepage}

\addtocontents{toc}{\setcounter{tocdepth}{1}}
\frame{\tableofcontents}

\section{Historia}

\begin{frame}{Geneza pracy}
\begin{itemize}
	\item Około połowy 2017 roku postanowiłem sformalizować sobie kilka algorytmów i struktur danych. Tak powstał projekt żyjący pod adresem \url{https://github.com/wkolowski/coq-algs}
	\item W semestrze zimowym 2017/2018 brałem udział w kursie Algorytmy Funkcyjne i Trwałe Struktury Danych (czy jak on tam się zwał), który skłonił mnie do sięgnięcia po książkę Okasakiego i próbę sformalizowania tego, co w niej znajdę.
	\item Przez kolejne $+-$ dwa i pół roku projekt ewoluował i działy się w nim różne rzeczy, takie jak badania nad spamiętywaniem czy dowodzeniem przez reflekcję.
\end{itemize}
\end{frame}

\begin{frame}{Skąd odkrycia?}
\begin{itemize}
	\item Pewnego razu postanowiłem sformalizować pokaźny wachlarz przeróżnych algorytmów sortowania.
	\item Podjąłem się go częściowo z nudów, a częściowo żeby nieco systematyczniej zbadać, jak trudno (lub łatwo) formalizuje się algorytmy w Coqu i dowodzi ich poprawności.
	\item Wcześniejsze formalizacje algorytmów w tym projekcie nie dawały dobrej odpowiedzi na to pytanie, bo dotyczyły przypadkowo dobranych problemów, a rozwiązania pochodziły głównie z książki Okasakiego.
\end{itemize}
\end{frame}

\begin{frame}{Algorytmy sortowania motorem napędowym nauki}
\begin{itemize}
	\item Spora liczba algorytmów i jeszcze większa mnogość ich wariantów bardzo szybko wymusiły wysoce abstrakcyjne i modularne podejście, a potężny system typów Coqa umożliwił (niemal) bezproblemową realizację tej wizji.
	\item W miarę postępów formalizacji poznałem też całą masę uniwersalnych prawidłowości, które następnie przekułem w pracy na tytułowe koncepcje i techniki.
	\item Ostatecznie przekonałem się, że dla wprawnego użytkownika Coqa, uzbrojonego w moje koncepcje i techniki, dowodzenie poprawności algorytmów jest niewiele trudniejsze niż sama ich implementacja (choć jest dużo bardziej pracochłonne).
	\item Co więcej, zarówno implementacja jak i weryfikacja stają się łatwiejsze, gdy rozważamy je razem.
\end{itemize}
\end{frame}

\begin{frame}{Pareto wiecznie żywy}
\begin{itemize}
	\item Porównanie algorytmów sortowania okazało się więc być strzałem w dziesiątkę.
	\item Zadziałała też niezawodna zasada Pareto: mimo, że znaczna większość czasu i kodu poświęcona została podstawowym strukturom danych takim jak kolejki, sterty czy samobalansujące się drzewa wyszukiwań, to największym źródłem odkryć i najbardziej istotnym dla napisania pracy elementem projektu było właśnie porównanie algorytmów sortowania.
\end{itemize}
\end{frame}

\begin{frame}{Motywacje}
\begin{itemize}
	\item Poznawszy wspaniałe techniki radzenia sobie z formalizacją algorytmów stosowalne we wszystkich w zasadzie językach z typami zależnymi, postanowiłem podzielić się nimi ze światem.
	\item Głównym celem pracy było bardzo przyjazne i dostępne dla zwykłych śmiertelników opisanie tego wszystkiego, w formie tutorialowej zbliżonej stylem do najlepszych dydaktycznie znanych mi postów na blogach.
\end{itemize}
\end{frame}

\section{Streszczenie pracy}

\begin{frame}{Abstrakt}
\begin{center}
	Omawiamy sposoby specyfikowania, implementowania i weryfikowania funkcyjnych algorytmów, skupiając się raczej na dowodach formalnych niż na asymptotycznej złożoności czy faktycznej wydajności. Prezentujemy koncepcje i techniki, obie często opierające się na jednej kluczowej zasadzie -- reifikacji i reprezentacji, za pomocą potężnego systemu typów Coqa, czegoś, co w klasycznym, imperatywnym podejściu jest nieuchwytne, jak przepływ informacji w dowodzie czy kształt rekursji funkcji. Nasze podejście obszernie ilustrujemy na przykładzie quicksorta. Ostatecznie otrzymujemy solidną i ogólną metodę, którą można zastosować do dowolnego algorytmu funkcyjnego.
\end{center}
\end{frame}

\begin{frame}{Jak sformalizować funkcyjny algorytm?}
\begin{itemize}
	\item Praca prezentuje 15 technik przydatnych przy formalizacji algorytmów funkcyjnych.
	\item Liczba 15 jest trochę naciągana, zresztą nie o ilość chodzi.
	\item Najlepiej rozumieć je jako podpunkty uniwersalnego planu, który prowadzi nas od problemu do formalnie zweryfikowanego algorytmu, który go rozwiązuje.
\end{itemize}
\end{frame}

\begin{frame}{Znajdź specyfikację problemu (sekcja 1.6 i rozdział 2)}
\begin{itemize}
	\item \#0: Dobra specyfikacja jest abstrakcyjna i prosta w użyciu.
	\item \#1: Dobra specyfikacja określa unikalny obiekt.
	\item \#2: Patchworkowa specyfikacja może zostać ulepszona przy użyciu defunkcjonalizacji (czyli przy użyciu definicji induktywnych zamiast kwantyfikatora uniwersalnego).
	\item \#3: Czasem można znaleźć lepszą specyfikację skupiając się na innym aspekcie zagadnienia.
\end{itemize}
\end{frame}

\begin{frame}{Znajdź algorytm, który rozwiązuje problem}
\begin{itemize}
	\item Łatwiej powiedzieć niż zrobić.
	\item Praca nie porusza tematyki wymyślania czy projektowania algorytmów - zakładamy, że formalizujemy znany już algorytm.
	\item Ostatnio wyszła ciekawa książka o projektowaniu algorytmów funkcyjnych, ale jeszcze nie czytałem: \href{https://www.amazon.com/Algorithm-Design-Haskell-Richard-Bird/dp/1108491618}{Algorithm Design with Haskell}
\end{itemize}
\end{frame}

\begin{frame}{Implement a template of the algorithm that abstracts over the exact details}
\begin{itemize}
	\item \#4: While implementing the template, ignore termination at first.
	\item \#6: Types of components of your template should contain enough evidence, but not too much!
	\item \#7: When dealing with many templates at once, make shared components into parameters. In all other cases, prefer bundled classes.
	\item \#8: Use the Inductive Domain Method to define a better, provably terminating algorithm template.
\end{itemize}
\end{frame}

\begin{frame}{Prove termination and correctness of the algorithm template}
\begin{itemize}
	\item \#12: Use the technique of Proof by Admission.
	\item \#9: Outline of termination proof: well-founded induction.
	\item \#11: Outline of correctness proof: functional induction.
\end{itemize}
\end{frame}


\begin{frame}{Provide a concrete default implementation together with all the proofs}
\begin{itemize}
	\item \#5: Provide a default implementation.
	\item \#10: Make sure that a default implementation can be run without any proof obligations, and that a provably terminating implementation can be run without having to prove correctness.
	\item \#13: If your default implementation or its proofs are too abstract, provide a more concrete version.
	\item \#14: When looking for default and concrete implementations, use type-driven development.
\end{itemize}
\end{frame}

\section{Podsumowanie i co dalej}


\begin{frame}{Konkluzja}
	In this thesis, we have described concepts and techniques useful for implementing and verifying functional algorithms. We worked in Coq, but our ideas readily transfer to other dependently typed languages, like Agda, Idris or F*. Some of the techniques (mostly those concerned with specification and implementation of the abstract template) are probably also useful in languages with weaker type systems, like Haskell, OCaml or F\#.
\end{frame}

\begin{frame}{Główna kontrybucja pracy}
\begin{itemize}
	\item Główną kontrybucją pracy jest systematyzacja wielu technik, ich synteza w spójną metodę i zastosowanie tej metody konkretnie do problemu formalizacji algorytmów funkcyjnych.
	\item Uwaga: nie przypisuję sobie odkrycia w zasadzie żadnej z opisanych przeze mnie koncepcji i technik -- część była znana już wcześniej, część ma status pewnego folkloru, a część jest na tyle nieuchwytna, że trzeba je wymyślić na nowo, żeby porządnie je zrozumieć.
\end{itemize}
\end{frame}

\begin{frame}{Pomniejsze kontrybucje}
\begin{itemize}
	\item Udało mi się w przyjazny i zrozumiały sposób opisać także wiele znanych już technik, które jednak dotychczas 
	\item Indukcja funkcyjna, elegancka metoda dowodzenia właściwości funkcji rekurencyjnych, nie została nigdzie opisana w sposób przyjazny dla początkujących.
	\item Metoda Bove-Capretta (co za okropna nazwa!) została opisana w wielu pracach, ale nie są one przyjazne dla początkujących.
	\item Type-driven development został przyjaźnie opisany, ale książka jest płatna i trochę przeterminowana.
	\item Spamowanie taktyką \texttt{admit} nie zostało nigdzie opisane jako systematyczna metoda dowodzenia i nie ma nawet nazwy, a jego związki z \textit{Hole-driven development} są nie do końca oczywiste.
\end{itemize}
\end{frame}

\begin{frame}{Related and further work}
	The approach presented in this thesis is powerful, but not complete and could be improved in many respects. Although we have seen some criteria for judging specifications and some techniques for improving them, it would be nice to have a general method for coming up with good specifications. Even though we did discuss well-founded induction, we haven't seen any techniques for constructing the most convenient well-founded relation for a given termination proof. We have also seen that the inductive domain method has some problems when dealing with functions that exhibit nested recursion or higher-order recursion.

	Moreover, we have skipped the issue of actually inventing the algorithm that we want to formalize. The classical-imperative paradigm knows many techniques of algorithm design and most of them transfer easily to the functional paradigm, but it would be very interesting to see how they interact with the rest of our approach -- maybe it's possible to synthesise the algorithm directly from the specification, or maybe the abstract template is easier to implement for greedy algorithms than for dynamic programming?
	
	It would also be worth exploring how other algorithmic activities described in section Worlds fit into our approach. An interesting link between complexity analysis and inductive types is Analytic Combinatorics, whose slogan is ``If you can specify it, you can analyze it''. Testing is also relevant to formally verified algorithms. Although, as Dijkstra famously put it, ``Testing can be used to show the presence of bugs, but never to show their absence!'', property-based testing is extremely efficient at generating counterexamples and can shorten the feedback loop between implementation and bug detection by many orders of magnitude.
	
	When formalizing algorithms without tests, we usually detect implementation bugs when we can't prove the algorithm correct, but before that happens we waste a lot of time pondering the basic dilemma: is it really incorrect or are we just incompetent at proving it correct?
	
	There has already been some work on property-based testing in Coq.
\end{frame}

\end{document}